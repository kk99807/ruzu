// Cypher grammar for ruzu Graph Database
// Supports: CREATE NODE TABLE, CREATE REL TABLE, CREATE node, CREATE relationship, MATCH with WHERE/RETURN, COPY

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

cypher_query = { SOI ~ statement ~ ";"? ~ EOI }
statement = { explain_query | copy_from | create_rel_table | create_node_table | match_create | create_node | match_query }

// EXPLAIN: Show query plan without executing
explain_query = {
    ^"EXPLAIN" ~ match_query
}

// DDL: CREATE NODE TABLE
create_node_table = {
    ^"CREATE" ~ ^"NODE" ~ ^"TABLE" ~ identifier ~
    "(" ~ column_list ~ "," ~ primary_key_clause ~ ")"
}

// DDL: CREATE REL TABLE
// Syntax: CREATE REL TABLE RelName(FROM SrcTable TO DstTable)
// Or: CREATE REL TABLE RelName(FROM SrcTable TO DstTable, prop1 TYPE1, prop2 TYPE2)
create_rel_table = {
    ^"CREATE" ~ ^"REL" ~ ^"TABLE" ~ identifier ~
    "(" ~ from_to_clause ~ rel_property_list? ~ ")"
}

from_to_clause = {
    ^"FROM" ~ identifier ~ ^"TO" ~ identifier
}

rel_property_list = {
    "," ~ column_def ~ ("," ~ column_def)*
}

column_list = { column_def ~ ("," ~ column_def)* }
column_def = { identifier ~ data_type }
data_type = { ^"STRING" | ^"INT64" }
primary_key_clause = { ^"PRIMARY" ~ ^"KEY" ~ "(" ~ identifier_list ~ ")" }

// DML: CREATE node
create_node = {
    ^"CREATE" ~ node_pattern
}

// DML: MATCH ... CREATE relationship
// Syntax: MATCH (a:Label {key: value}), (b:Label {key: value}) CREATE (a)-[:REL_TYPE {props}]->(b)
match_create = {
    ^"MATCH" ~ match_node_filter ~ "," ~ match_node_filter ~
    ^"CREATE" ~ relationship_pattern
}

match_node_filter = {
    "(" ~ identifier ~ ":" ~ identifier ~ property_filter? ~ ")"
}

property_filter = {
    "{" ~ property_key_value ~ "}"
}

property_key_value = {
    identifier ~ ":" ~ literal
}

// Relationship pattern for creation: (var1)-[:REL_TYPE {props}]->(var2)
relationship_pattern = {
    "(" ~ identifier ~ ")" ~ "-" ~ rel_type_pattern ~ "->" ~ "(" ~ identifier ~ ")"
}

rel_type_pattern = {
    "[" ~ ":" ~ identifier ~ rel_properties? ~ "]"
}

rel_properties = {
    "{" ~ property_list ~ "}"
}

node_pattern = {
    "(" ~ ":" ~ identifier ~ properties ~ ")"
}

properties = { "{" ~ property_list ~ "}" }
property_list = { property ~ ("," ~ property)* }
property = { identifier ~ ":" ~ literal }

// Query: MATCH ... WHERE ... RETURN [ORDER BY] [SKIP] [LIMIT]
// Supports both node-only and relationship patterns
match_query = {
    ^"MATCH" ~ (match_rel_pattern | match_pattern) ~
    where_clause? ~
    return_clause ~
    order_by_clause? ~
    skip_clause? ~
    limit_clause?
}

// Match pattern for nodes only: (var:Label)
match_pattern = {
    "(" ~ identifier ~ ":" ~ identifier ~ ")"
}

// Match pattern for relationships: (a:Label)-[r:REL_TYPE]->(b:Label)
// Also supports: (a:Label)-[:REL_TYPE]->(b:Label) (anonymous relationship)
// Also supports: (a:Label {key: value})-[:REL_TYPE]->(b:Label)
match_rel_pattern = {
    match_node_with_filter ~ "-" ~ match_rel_type ~ "->" ~ match_node_with_filter
}

match_node_with_filter = {
    "(" ~ identifier ~ ":" ~ identifier ~ property_filter? ~ ")"
}

// Relationship type with optional path length
// Supports: [:REL_TYPE], [r:REL_TYPE], [:REL_TYPE*1..3], [r:REL_TYPE*1..3]
match_rel_type = {
    "[" ~ identifier? ~ ":" ~ identifier ~ path_length? ~ "]"
}

// Variable-length path: *min..max (e.g., *1..3, *2..5)
path_length = {
    "*" ~ integer_literal ~ ".." ~ integer_literal
}

where_clause = { ^"WHERE" ~ expression }
return_clause = { ^"RETURN" ~ return_item_list }

// Return items: can be projections or aggregates
return_item_list = { return_item ~ ("," ~ return_item)* }
return_item = { aggregate_expr | projection }

projection_list = { projection ~ ("," ~ projection)* }
projection = { identifier ~ "." ~ identifier }

// Aggregate functions: COUNT(*), COUNT(expr), SUM(expr), AVG(expr), MIN(expr), MAX(expr)
aggregate_expr = {
    count_star |
    aggregate_function ~ "(" ~ (projection | "*") ~ ")"
}
count_star = { ^"COUNT" ~ "(" ~ "*" ~ ")" }
aggregate_function = { ^"COUNT" | ^"SUM" | ^"AVG" | ^"MIN" | ^"MAX" }

// ORDER BY clause
order_by_clause = { ^"ORDER" ~ ^"BY" ~ order_by_item_list }
order_by_item_list = { order_by_item ~ ("," ~ order_by_item)* }
order_by_item = { projection ~ order_direction? }
order_direction = { ^"ASC" | ^"DESC" }

// SKIP clause
skip_clause = { ^"SKIP" ~ integer_literal }

// LIMIT clause
limit_clause = { ^"LIMIT" ~ integer_literal }

// Expressions
expression = { comparison }
comparison = { projection ~ comparison_op ~ literal }
comparison_op = { ">=" | "<=" | "<>" | ">" | "<" | "=" }

// Literals
literal = { string_literal | integer_literal }
string_literal = @{ "'" ~ (!"'" ~ ANY)* ~ "'" }
integer_literal = @{ "-"? ~ ASCII_DIGIT+ }

// Identifiers
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
identifier_list = { identifier ~ ("," ~ identifier)* }

// COPY command for bulk CSV import
// Syntax: COPY TableName FROM 'path/to/file.csv'
// Or: COPY TableName FROM 'path/to/file.csv' (HEADER = true, DELIM = ',')
copy_from = {
    ^"COPY" ~ identifier ~ ^"FROM" ~ file_path ~ copy_options?
}

file_path = @{ "'" ~ (!"'" ~ ANY)* ~ "'" }

copy_options = {
    "(" ~ copy_option ~ ("," ~ copy_option)* ~ ")"
}

copy_option = {
    copy_option_header | copy_option_delim | copy_option_skip | copy_option_ignore_errors
}

copy_option_header = { ^"HEADER" ~ "=" ~ bool_literal }
copy_option_delim = { (^"DELIMITER" | ^"DELIM") ~ "=" ~ string_literal }
copy_option_skip = { ^"SKIP" ~ "=" ~ integer_literal }
copy_option_ignore_errors = { ^"IGNORE_ERRORS" ~ "=" ~ bool_literal }

bool_literal = { ^"TRUE" | ^"FALSE" }
